#!/bin/bash

#
# Example:
# curl -fsSL http://tiger/aqualinkd-kit-tools/cleanup | sudo bash -s -- m=smtp.example.com:25 r=fred@bloggs.com
# curl -fsSL https://raw.githubusercontent.com/aqualinkd/AqualinkD-kit-tools/refs/heads/main/cleanup | sudo bash -s --
# curl -fsSL https://raw.githubusercontent.com/aqualinkd/AqualinkD-kit-tools/refs/heads/main/cleanup | sudo bash -s -- m=smtp.example.com:25 r=fred@bloggs.com s=sender@address.com



RADXA_BOOT_CFG="/boot/extlinux/extlinux.conf"
PI_BOOT_CFG="/boot/firmware/config.txt"

#https://raw.githubusercontent.com/aqualinkd/AqualinkD-kit-tools/refs/heads/main/radxa-patch-update?token=XXXXXXXXXXXXXXX

RADXA_PATCH_URL="https://raw.githubusercontent.com/aqualinkd/AqualinkD-kit-tools/refs/heads/main/radxa-patch-update"
PI_PATCH_URL="https://raw.githubusercontent.com/aqualinkd/AqualinkD-kit-tools/refs/heads/main/raspberry-patch-update"

LOCAL_URL="http://tiger/"
RADXA_PATCH_URL="$LOCAL_URL/aqualinkd-kit-tools/radxa-patch-update"
PI_PATCH_URL="$LOCAL_URL/aqualinkd-kit-tools/raspberry-patch-update"

TRUE=0
FALSE=1

_pi=$FALSE
_radxa=$FALSE


# Define colors
GREEN='\e[32m'
RED='\e[31m'
NC='\e[0m' # No Color (Reset)


# check root
if [ "$EUID" -ne 0 ]; then
  echo "Please run as root"
  exit 1
fi

_model=$(tr -d '\0' < /sys/firmware/devicetree/base/model 2>/dev/null || echo "Unknown")
echo "$_model"

if [[ "$_model" == *"Raspberry Pi"* ]]; then
  _pi=$TRUE
elif [[ "$_model" == *"Radxa ZERO"* ]]; then
  _radxa=$TRUE
else
  echo "Unknown SBC: $_model"
  exit 1
fi


get_timezone() {
  #timedatectl show --value -p Timezone
  echo "$(timedatectl show --value -p Timezone) - $(date +%Z)"
  # Output: America/Chicago
}

check_us_timezone() {
  echo -e "Timezone is ${GREEN}`get_timezone`${NC}"

  # Force tty since this is pipe from curl
  read -p 'Did you want to change time zone? (y/n) ' -n 1 -r < /dev/tty
  echo ""
  if [[ $REPLY =~ ^[Nn]$ ]]; then
    return
  fi
  
    local labels=("Eastern" "Central" "Mountain" "Pacific" "Alaska" "Hawaii")
    local cities=("America/New_York" "America/Chicago" "America/Denver" \
                  "America/Los_Angeles" "America/Anchorage" "Pacific/Honolulu")

    echo "Select US Timezone:"
    for i in "${!labels[@]}"; do
        echo "$((i+1))) ${labels[$i]}"
    done

    # < /dev/tty ensures the input comes from the user's keyboard, 
    # even if the script was piped into bash via curl.
    if read -rn 1 -p "Choice (1-6): " choice < /dev/tty; then
        echo "" # New line after choice
        if [[ "$choice" =~ [1-6] ]]; then
            local idx=$((choice - 1))
            local target="${cities[$idx]}"
            
            echo "Updating to ${labels[$idx]} ($target)..."
            sudo timedatectl set-timezone "$target"
            
            # Legacy sync for Debian 11/12
            [ -f /etc/timezone ] && echo "$target" | sudo tee /etc/timezone > /dev/null
            
            # Clean output (no leading/trailing spaces)
            timedatectl | grep "Time zone" | xargs
        else
            echo "Invalid selection."
        fi
    fi

  check_us_timezone
}


check_raspiconfig_options() {
  if grep -q "^[[:space:]]*dtparam=ant2" $PI_BOOT_CFG; then
    echo -e "External Antenna is ${GREEN}ENABLED!${NC}"
  else
    echo -e "External Antenna is ${RED}DISABLED!${NC}"
  fi

  read -p 'Did you want to change Antenna type? (y/n) ' -n 1 -r < /dev/tty
  echo ""
  if [[ $REPLY =~ ^[Nn]$ ]]; then
    return
  fi
  
  raspi-config
  check_raspiconfig_options
}

check_rsetup_options() {
  if grep -q "external-antenna.dtbo" $RADXA_BOOT_CFG; then
    echo -e "External Antenna is ${GREEN}ENABLED!${NC}"
  else
    echo -e "External Antenna is ${RED}DISABLED!${NC}"
  fi

  read -p 'Did you want to change Antenna type? (y/n) ' -n 1 -r < /dev/tty
  echo ""
  if [[ $REPLY =~ ^[Nn]$ ]]; then
    return
  fi
  
  check_rsetup_options
}

check_wifi_visibility() {
    echo "Scanning for Wi-Fi networks..."
    
    # Trigger rescan
    sudo nmcli device wifi rescan 2>/dev/null
    sleep 2

    local wifi_list
    wifi_list=$(sudo nmcli --colors yes -f SSID,MODE,CHAN,RATE,SIGNAL,BARS,SECURITY device wifi list | tee /dev/tty)

    # Process the list for the count
    # Note: grep handles the color codes fine when looking for the header
    local count
    count=$(echo "$wifi_list" | grep -v "SSID" | grep -v '^--' | grep -v '^$' | wc -l)

    echo "------------------------------------------"
    if [[ "$count" -gt 0 ]]; then
        echo -e "${GREEN}[OK]${NC} Wi-Fi found $count network(s)."
        return 0
    else
        echo -e "${RED}[ERROR${NC} No Wi-Fi networks found in range!"
        return 1
    fi
}

check_mmc_space() {
    local dev="/dev/mmcblk0"
    local threshold_mb=100

    if [ ! -b "$dev" ]; then
        echo "Error: $dev not found."
        return 1
    fi

    # parted -m lists free space in megabytes (MB)
    # Filter for 'free' segments and extract the size
    local free_mb
    free_mb=$(sudo parted -m "$dev" unit MB print free | grep ":free;" | tail -n 1 | cut -d: -f4 | sed 's/MB//')

    # Compare as integers (bc used for decimal handling if needed)
    if [ -n "$free_mb" ] && (( ${free_mb%.*} >= threshold_mb )); then
        echo -e "${RED}WARNING: Disk is NOT fully partitioned.${NC}"
        echo -e "${free_mb}MB of unallocated space is available."
        read -p 'Did you want to continue (y/n) ' -n 1 -r < /dev/tty
        echo ""
        if [[ $REPLY =~ ^[Nn]$ ]]; then
          exit
        fi
    else
        echo -e "Disk is fully partitioned (Unallocated space is ${GREEN}${free_mb}MB${NC})."
    fi
}

show_mem_disk() {
  local mem=$(free --mega | awk '/^Mem:/{printf "%.0fG", $2/1000}')
  local disk=$(lsblk -bdno SIZE /dev/mmcblk0 | awk '{printf "%.0fG", $1/1000/1000/1000}')

  if [ "$1" == "raw" ]; then
    echo -e "Memory: $mem\nDisk: $disk"
  else
    echo -e "Memory : ${GREEN}${mem}${NC}"
    echo -e "Disk   : ${GREEN}${disk}${NC}"
  fi
}

show_wifi_mac() {
  for interface in /sys/class/net/*; do
    if [ -d "$interface/wireless" ] || [ -d "$interface/phy80211" ]; then
      local mac=$(cat "$interface/address")
      if [ "$1" == "raw" ]; then
        echo "MAC: $mac"
      else
        echo -e "MAC    : ${GREEN}${mac}${NC}"
      fi
      return 0
    fi
  done
  return 1
}


clean_logs() {

  read -p 'Did you want to purge logs (y/n) ' -n 1 -r < /dev/tty
  echo ""
  if [[ $REPLY =~ ^[Nn]$ ]]; then
    return
  fi

  echo "Cleaning system and user journals..."
  # Rotate and vacuum are sufficient; never rm -rf the journal directory while the service is running.
  sudo journalctl --rotate --vacuum-time=1s
  sudo journalctl --user --rotate --vacuum-time=1s

  echo "Clearing system logs..."
  # Clean traditional text logs without deleting the files themselves (preserves permissions)
  sudo find /var/log -type f -regex ".*\.log\|.*\.gz\|.*.[0-9]" -exec tee {} </dev/null >/dev/null \;

  echo "Purging shell histories..."
  # Clear current session memory
  history -c 
  
  # Truncate files (more effective than rm for active shell handles)
  true > ~/.bash_history
  [ -f /root/.bash_history ] && sudo sh -c "true > /root/.bash_history"
  
  # Optional: clear the current session's histfile immediately
  export HISTSIZE=0
  
  echo "Done. Logs vacuumed and histories truncated."
}


send_smtp_email() {
  # Validate required CLI args (m= and r=)
  if [[ -z "$SMTP_SERVER_ARG" || -z "$RECIPIENT_EMAIL_ARG" ]]; then
    echo -e "${RED}ERROR:${NC} both SMTP server (m=server[:port]) and recipient (r=address) must be provided."
    return 1
  fi

  local smtp_server="$SMTP_SERVER_ARG"
  local smtp_port=25

  # If smtp_server provided as host:port, split it
  if [[ "$smtp_server" == *:* ]]; then
    smtp_port="${smtp_server#*:}"
    smtp_server="${smtp_server%%:*}"
  fi

  local recipient_email="$RECIPIENT_EMAIL_ARG"
  # Sender address (bare) and header (with display name)
  local sender_addr="${SENDER_ARG:-$recipient_email}"
  local sender_header="AqualinkD kit setup <$sender_addr>"
  local subject="System Report: $(hostname)"

  # Check if SMTP server is reachable/resolvable before doing work
  if ! getent hosts "$smtp_server" >/dev/null 2>&1; then
    echo "Error: SMTP Server '$smtp_server' cannot be resolved (DNS failure)."
    return 1
  fi

  local raw_stats=$(show_mem_disk raw)
  local raw_mac=$(show_wifi_mac raw)
  local raw_model=$(tr -d '\0' < /sys/firmware/devicetree/base/model 2>/dev/null || echo "Unknown Model")
  local raw_tz=$(timedatectl show --value -p Timezone) - $(date +%Z)

  case "$TRUE" in
  "$_pi")
    grep -q "^[[:space:]]*dtparam=ant2" "$PI_BOOT_CFG" && raw_antenna="External" || raw_antenna="Internal"
    ;;
  "$_radxa")
    grep -q "external-antenna.dtbo" "$RADXA_BOOT_CFG" && raw_antenna="External" || raw_antenna="Internal"
    ;;
  *)
    raw_antenna="Unknown"
    ;;
  esac

  # Build the actual body string
  local message=$(cat <<EOF
System Report for $(hostname)
Date: $(date)
--------------------------------------
Model:  $raw_model
$raw_stats
$raw_mac
TZ: $raw_tz
Antenna: $raw_antenna
--------------------------------------
EOF
)

  # Open Connection
  if ! exec 3<>/dev/tcp/"$smtp_server"/"$smtp_port"; then
    echo "Error: Could not connect to $smtp_server on port $smtp_port"
    return 1
  fi

  # SMTP Helper
  send() {
    echo -ne "$1\r\n" >&3
    sleep 0.5
  }

  # SMTP Handshake
  send "HELO $(hostname)"
  send "MAIL FROM: <$sender_addr>"
  send "RCPT TO: <$recipient_email>"
  send "DATA"
  
  # Headers
  echo -ne "From: $sender_header\r\n" >&3
  echo -ne "To: $recipient_email\r\n" >&3
  echo -ne "Subject: $subject\r\n" >&3
  echo -ne "Content-Type: text/plain; charset=UTF-8\r\n" >&3
  echo -ne "\r\n" >&3 

  # Send Body Content
  echo -ne "$message\r\n" >&3
  
  send "."
  send "QUIT"
  exec 3>&-
  echo "Email sent successfully to $recipient_email"
}

########################################################################
#
#.  main
#

CALLED_URL=""
SMTP_SERVER_ARG=""
RECIPIENT_EMAIL_ARG=""
SENDER_ARG=""

# Loop through all arguments passed after the "--"
for arg in "$@"; do
  case $arg in
    url=*)
      # Strip "url=" from the start of the string
      CALLED_URL="${arg#url=}"
      shift # Remove from processing
      ;;
    m=*)
      SMTP_SERVER_ARG="${arg#m=}"
      shift
      ;;
    s=*)
      SENDER_ARG="${arg#s=}"
      shift
      ;;
    r=*)
      RECIPIENT_EMAIL_ARG="${arg#r=}"
      shift
      ;;
  esac
done

# Check if it was found
if [[ -n "$CALLED_URL" ]]; then
    echo "This script was downloaded from: $CALLED_URL"
    RADXA_PATCH_URL="$CALLED_URL/aqualinkd-kit-tools/radxa-patch-update"
    PI_PATCH_URL="$CALLED_URL/aqualinkd-kit-tools/raspberry-patch-update"
#else
    #echo "No URL parameter provided."
fi

show_mem_disk
show_wifi_mac
check_mmc_space

# Check antenna
if [[ "$_pi" -eq "$TRUE" ]]; then
    check_raspiconfig_options
elif [[ "$_radxa" -eq "$TRUE" ]]; then
    check_rsetup_options
#else
    # Generic Linux logic
fi

# Check time zone
check_us_timezone


read -p 'Do you want to run patch update? (y/n) ' -n 1 -r < /dev/tty
echo ""
if [[ $REPLY =~ ^[Yy]$ ]]; then
  if [[ "$_pi" -eq "$TRUE" ]]; then
    curl -fsSL $PI_PATCH_URL | sudo bash -s --
  elif [[ "$_radxa" -eq "$TRUE" ]]; then
    curl -fsSL $RADXA_PATCH_URL | sudo bash -s --
  fi
else
  echo ""
fi

if ! check_wifi_visibility; then
    echo "${RED}[ERROR]${EM} No networks found. Check hardware."
    exit 1
fi

# If we reached here, it means it passed!

# Only ask to send email when both short CLI params were provided
if [[ -n "$SMTP_SERVER_ARG" && -n "$RECIPIENT_EMAIL_ARG" ]]; then
  read -p 'Do you want to send system report email? (y/n) ' -n 1 -r < /dev/tty
  echo ""
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    send_smtp_email
  fi
fi

clean_logs

read -rep 'Halt / Reboot system, or exit? (H/R/E)' -n 1 -r < /dev/tty
echo ""
if [[ $REPLY =~ ^[Hh]$ ]]; then
  echo "Halting system!"
  sudo halt
elif [[ $REPLY =~ ^[Rr]$ ]]; then
  echo "Rebooting system!"
  sudo reboot
else
  echo ""
fi


