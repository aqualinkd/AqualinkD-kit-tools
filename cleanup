#!/bin/bash

#
# curl -fsSL http://tiger/scratch/raspberry/cleanup | sudo bash -s --
# curl -fsSL http://tiger/scratch/radxa/images/cleanup | sudo bash -s --


RADXA_BOOT_CFG="/boot/extlinux/extlinux.conf"
PI_BOOT_CFG="/boot/firmware/config.txt"

#https://raw.githubusercontent.com/aqualinkd/AqualinkD-kit-tools/refs/heads/main/radxa-patch-update?token=XXXXXXXXXXXXXXX

RADXA_PATCH_URL="https://raw.githubusercontent.com/aqualinkd/AqualinkD-kit-tools/refs/heads/main/radxa-patch-update"
PI_PATCH_URL="https://raw.githubusercontent.com/aqualinkd/AqualinkD-kit-tools/refs/heads/main/raspberry-patch-update"

LOCAL_URL="http://tiger/"
RADXA_PATCH_URL="$LOCAL_URL/aqualinkd-kit-tools/radxa-patch-update"
PI_PATCH_URL="$LOCAL_URL/aqualinkd-kit-tools/raspberry-patch-update"

TRUE=0
FALSE=1

_pi=$FALSE
_radxa=$FALSE


# Define colors
GREEN='\e[32m'
RED='\e[31m'
NC='\e[0m' # No Color (Reset)


# check root
if [ "$EUID" -ne 0 ]; then
  echo "Please run as root"
  exit 1
fi

if grep -q "Raspberry Pi" /proc/device-tree/model 2>/dev/null; then
  echo "This is a Raspberry Pi."
  _pi=$TRUE
elif grep -q "Radxa ZERO" /proc/device-tree/model 2>/dev/null; then
  echo "This is a RADXA"
  _radxa=$TRUE
else
  echo "Unknown SBC"
  exit 1
fi


get_timezone() {
  #timedatectl show --value -p Timezone
  echo "$(timedatectl show --value -p Timezone) - $(date +%Z)"
  # Output: America/Chicago
}

check_us_timezone() {
  echo -e "Timezone is ${GREEN}`get_timezone`${NC}"

  # Force tty since this is pipe from curl
  read -p 'Did you want to change time zone? (y/n) ' -n 1 -r < /dev/tty
  echo ""
  if [[ $REPLY =~ ^[Nn]$ ]]; then
    return
  fi
  
    local labels=("Eastern" "Central" "Mountain" "Pacific" "Alaska" "Hawaii")
    local cities=("America/New_York" "America/Chicago" "America/Denver" \
                  "America/Los_Angeles" "America/Anchorage" "Pacific/Honolulu")

    echo "Select US Timezone:"
    for i in "${!labels[@]}"; do
        echo "$((i+1))) ${labels[$i]}"
    done

    # < /dev/tty ensures the input comes from the user's keyboard, 
    # even if the script was piped into bash via curl.
    if read -rn 1 -p "Choice (1-6): " choice < /dev/tty; then
        echo "" # New line after choice
        if [[ "$choice" =~ [1-6] ]]; then
            local idx=$((choice - 1))
            local target="${cities[$idx]}"
            
            echo "Updating to ${labels[$idx]} ($target)..."
            sudo timedatectl set-timezone "$target"
            
            # Legacy sync for Debian 11/12
            [ -f /etc/timezone ] && echo "$target" | sudo tee /etc/timezone > /dev/null
            
            # Clean output (no leading/trailing spaces)
            timedatectl | grep "Time zone" | xargs
        else
            echo "Invalid selection."
        fi
    fi

  check_us_timezone
}


check_raspiconfig_options() {
  if grep -q "^[[:space:]]*dtparam=ant2" $PI_BOOT_CFG; then
    echo -e "External Antenna is ${GREEN}ENABLED!${NC}"
  else
    echo -e "External Antenna is ${RED}DISABLED!${NC}"
  fi

  read -p 'Did you want to change Antenna type? (y/n) ' -n 1 -r < /dev/tty
  echo ""
  if [[ $REPLY =~ ^[Nn]$ ]]; then
    return
  fi
  
  raspi-config
  check_raspiconfig_options
}

check_rsetup_options() {
  if grep -q "external-antenna.dtbo" $RADXA_BOOT_CFG; then
    echo -e "External Antenna is ${GREEN}ENABLED!${NC}"
  else
    echo -e "External Antenna is ${RED}DISABLED!${NC}"
  fi

  read -p 'Did you want to change Antenna type? (y/n) ' -n 1 -r < /dev/tty
  echo ""
  if [[ $REPLY =~ ^[Nn]$ ]]; then
    return
  fi
  
  check_rsetup_options
}

check_wifi_visibility() {
    echo "Scanning for Wi-Fi networks..."
    
    # Trigger rescan
    sudo nmcli device wifi rescan 2>/dev/null
    sleep 2

    local wifi_list
    wifi_list=$(sudo nmcli --colors yes -f SSID,MODE,CHAN,RATE,SIGNAL,BARS,SECURITY device wifi list | tee /dev/tty)

    # Process the list for the count
    # Note: grep handles the color codes fine when looking for the header
    local count
    count=$(echo "$wifi_list" | grep -v "SSID" | grep -v '^--' | grep -v '^$' | wc -l)

    echo "------------------------------------------"
    if [[ "$count" -gt 0 ]]; then
        echo -e "${GREEN}[OK]${NC} Wi-Fi found $count network(s)."
        return 0
    else
        echo -e "${RED}[ERROR${NC} No Wi-Fi networks found in range!"
        return 1
    fi
}

check_mmc_space() {
    local dev="/dev/mmcblk0"
    local threshold_mb=100

    if [ ! -b "$dev" ]; then
        echo "Error: $dev not found."
        return 1
    fi

    # parted -m lists free space in megabytes (MB)
    # Filter for 'free' segments and extract the size
    local free_mb
    free_mb=$(sudo parted -m "$dev" unit MB print free | grep ":free;" | tail -n 1 | cut -d: -f4 | sed 's/MB//')

    # Compare as integers (bc used for decimal handling if needed)
    if [ -n "$free_mb" ] && (( ${free_mb%.*} >= threshold_mb )); then
        echo -e "${RED}WARNING: Disk is NOT fully partitioned.${NC}"
        echo -e "${free_mb}MB of unallocated space is available."
        read -p 'Did you want to continue (y/n) ' -n 1 -r < /dev/tty
        echo ""
        if [[ $REPLY =~ ^[Nn]$ ]]; then
          exit
        fi
    else
        echo -e "Disk is fully partitioned (Unallocated space is ${GREEN}${free_mb}MB${NC})."
    fi
}

show_mem_disk() {
  #mem=$(free --giga | awk '/^Mem:/{printf " %sG",$2}')
  mem=$(free -h --si | awk '/^Mem:/{printf " %s",$2}')
  disk=$(lsblk -do SIZE /dev/mmcblk0 | tail -n 1)

  echo -e "Memory :${GREEN}${mem}${NC}"
  echo -e "Disk   :${GREEN}${disk}${NC}"
}


clean_logs() {

  read -p 'Did you want to purge logs (y/n) ' -n 1 -r < /dev/tty
  echo ""
  if [[ $REPLY =~ ^[Nn]$ ]]; then
    return
  fi

  echo "Cleaning system and user journals..."
  # Rotate and vacuum are sufficient; never rm -rf the journal directory while the service is running.
  sudo journalctl --rotate --vacuum-time=1s
  sudo journalctl --user --rotate --vacuum-time=1s

  echo "Clearing system logs..."
  # Clean traditional text logs without deleting the files themselves (preserves permissions)
  sudo find /var/log -type f -regex ".*\.log\|.*\.gz\|.*.[0-9]" -exec tee {} </dev/null >/dev/null \;

  echo "Purging shell histories..."
  # Clear current session memory
  history -c 
  
  # Truncate files (more effective than rm for active shell handles)
  true > ~/.bash_history
  [ -f /root/.bash_history ] && sudo sh -c "true > /root/.bash_history"
  
  # Optional: clear the current session's histfile immediately
  export HISTSIZE=0
  
  echo "Done. Logs vacuumed and histories truncated."
}


########################################################################
#
#.  main
#

CALLED_URL=""

# Loop through all arguments passed after the "--"
for arg in "$@"; do
  case $arg in
    url=*)
      # Strip "url=" from the start of the string
      CALLED_URL="${arg#url=}"
      shift # Remove from processing
      ;;
  esac
done

# Check if it was found
if [[ -n "$CALLED_URL" ]]; then
    echo "This script was downloaded from: $CALLED_URL"
    RADXA_PATCH_URL="$CALLED_URL/aqualinkd-kit-tools/radxa-patch-update"
    PI_PATCH_URL="$CALLED_URL/aqualinkd-kit-tools/raspberry-patch-update"
#else
    #echo "No URL parameter provided."
fi

show_mem_disk
check_mmc_space

# Check antenna
if [[ "$_pi" -eq "$TRUE" ]]; then
    check_raspiconfig_options
elif [[ "$_radxa" -eq "$TRUE" ]]; then
    check_rsetup_options
#else
    # Generic Linux logic
fi

# Check time zone
check_us_timezone


read -p 'Do you want to run patch update? (y/n) ' -n 1 -r < /dev/tty
echo ""
if [[ $REPLY =~ ^[Yy]$ ]]; then
  if [[ "$_pi" -eq "$TRUE" ]]; then
    curl -fsSL $PI_PATCH_URL | sudo bash -s --
  elif [[ "$_radxa" -eq "$TRUE" ]]; then
    curl -fsSL $RADXA_PATCH_URL | sudo bash -s --
  fi
else
  echo ""
fi

if ! check_wifi_visibility; then
    echo "${RED}[ERROR]${EM} No networks found. Check hardware."
    exit 1
fi

# If we reached here, it means it passed!

clean_logs

read -rep 'Halt / Reboot system, or exit? (H/R/E)' -n 1 -r < /dev/tty
echo ""
if [[ $REPLY =~ ^[Hh]$ ]]; then
  echo "Halting system!"
  sudo halt
elif [[ $REPLY =~ ^[Rr]$ ]]; then
  echo "Rebooting system!"
  sudo reboot
else
  echo ""
fi


